from datetime import datetime, timedelta
import polyline
import requests
import json
import math
import time
import sqlite3

# Obtain API keys from HERE and Windy
here_api_key = 'ENTER API KEY HERE'
windy_api_key = 'ENTER API KEY HERE'


# Fire should have been started/updated at least 120 minutes ago
max_cycles = 6


# Used to initialize the ForeFire simulation at a given time and location
def initialize_sim(fid, timestamp, lat, lon):
    coords = polyline.encode([(lat, lon)], 5)
    wind_x, wind_y = get_wind(lat, lon)

    try:
        # Make a request to the ForeFire API
        requests.post("http://forefire.univ-corse.fr/api/dev/php/forefireAPI.php",
                      data={'command': 'init',
                            'path': fid,
                            'coords': coords,
                            'ventX': wind_x,
                            'ventY': wind_y,
                            'date': timestamp.strftime('%Y-%m-%dT%H:%M:%SZ')},
                      headers={'X-Requested-With': 'XMLHttpRequest'},
                      timeout=1)
    except requests.exceptions.ReadTimeout:
        # Request does not return something, so wait for timeout before continuing
        print("Fire simulation was initialized correctly.")

        # Compute the number of cycles from fire ignition until now
        t_diff = datetime.now() - timestamp
        n_cycles = math.floor(t_diff.total_seconds() / 1200)

        # Run a propagation of the simulator and return shape
        return propagate_sim(fid, n_cycles)

    except requests.exceptions.ConnectionError:
        print("Server cannot be reached.")
        return None


# Method used to propagate the ForeFire simulator with a given number of cycles
# Please note that one cycle equals 20 minutes
def propagate_sim(fid, n_cycles):
    # Propagate the simulator n times
    for i in range(n_cycles):
        requests.post("http://forefire.univ-corse.fr/api/dev/php/forefireAPI.php",
                      data={'command': 'step',
                            'path': fid},
                      headers={'X-Requested-With': 'XMLHttpRequest'},
                      timeout=5)

        # Sleep for a second in order to ensure enough time to handle multiple requests
        time.sleep(1)

    # Validate how many cycles have been simulated until now
    n_done = requests.post("http://forefire.univ-corse.fr/api/dev/php/forefireAPI.php",
                           data={'command': 'getListOfStates',
                                 'path': fid},
                           headers={'X-Requested-With': 'XMLHttpRequest'},
                           timeout=5)
    n_done = len(n_done.text.split('\n'))

    print("Performed " + str(n_done) + " cycles of the simulation.")

    # Get the latest fire shape in order to create a polygon
    result = requests.post("http://forefire.univ-corse.fr/api/dev/php/forefireAPI.php",
                           data={'command': 'getState',
                                 'path': fid,
                                 'element': 'fronts',
                                 'indice': n_done},
                           headers={'X-Requested-With': 'XMLHttpRequest'},
                           timeout=5)

    return create_polygon(result.json()['fronts'][0]['coordinates'])


# Create a polygon shape from the string generated by ForeFire
def create_polygon(coords_string):
    shape = {'type': 'Polygon',
             'coordinates': [[]]}

    coords = coords_string.split(',0 ')
    coords[-1] = coords[-1][:-2]

    # Convert coordinates into the right format
    for coord in coords:
        lon, lat = coord.split(',')
        lon, lat = float(lon), float(lat)
        shape['coordinates'][0].append([lon, lat])

    shape['coordinates'][0].append(shape['coordinates'][0][0])

    # Return the shape
    return shape


# Insert a new fire into the database, initialize the simulation and add to HERE XYZ
def insert_fire(lat, lon, t_init, comments):
    conn = sqlite3.connect('db/db.sqlite')
    cursor = conn.cursor()

    fid = 'EW_' + t_init.strftime('%Y_%m_%d_%H%M%S%f')

    # Initialize the simulation which returns the fire fronts
    init_fronts = initialize_sim(fid, t_init, lat, lon)
    if init_fronts:
        try:
            # Add new space in HERE XYZ corresponding to the fire
            r = requests.post("https://xyz.api.here.com/hub/spaces",
                              json={
                                  "title": fid,
                                  "description": "Fire started on location " + str(lat) + ", " + str(lon)
                              },
                              headers={'Authorization': "Bearer " + here_api_key})
            sid = r.json()['id']

            # Insert the fire front polygon into HERE XYZ
            insert_feature(sid, init_fronts)

            # Create the new wildfire in the local SQLite database
            query = """INSERT INTO wildfires (fid, sid, latitude, longitude, t_init, t_updated, comments, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"""
            cursor.execute(query, (fid, sid, lat, lon, t_init, datetime.now(), comments, True))
        except requests.exceptions.ConnectionError:
            print("HERE XYZ cannot be reached.")
    else:
        print("Fire could not be added to the system.")

    # Request the updated rows in the local database to return to web server
    cursor.execute("SELECT sid, ROUND(latitude, 5), ROUND(longitude, 5), strftime('%d-%m-%Y %H:%M', t_init), strftime('%d-%m-%Y %H:%M', t_updated), comments, active FROM wildfires")
    rows = cursor.fetchall()

    conn.commit()
    cursor.close()
    conn.close()

    print("Wildfire was added to the system.")

    # Return the updated list of wildfires in the database
    return rows


# On a periodic basis, the active fires are updated
# This entails propagation in the simulator and subsequently updating the HERE XYZ polygons
def update_fires():
    conn = sqlite3.connect('db/db.sqlite')
    cursor = conn.cursor()

    t_prop = datetime.now() - timedelta(minutes=20)

    # Select the fires which are currently active and should be updated (> 20 min. ago)
    cursor.execute("""SELECT fid, sid, t_updated FROM wildfires WHERE active == 1 AND t_updated < (?)""",
                   (t_prop.strftime('%Y-%m-%d %H:%M:%S.%f'),))

    fires = cursor.fetchall()

    for fire in fires:
        t_last = datetime.strptime(fire[2], '%Y-%m-%d %H:%M:%S.%f')
        t_diff = t_prop - t_last

        # Compute how many cycles should be executed in ForeFire (up to max_cycles)
        n_cycles = math.ceil(t_diff.total_seconds() / 1200)
        n_cycles = min((n_cycles, max_cycles))

        # Retrieve updated fronts and insert polygons into HERE XYZ
        updated_fronts = propagate_sim(fire[0], n_cycles)
        insert_feature(fire[1], updated_fronts)

        # Update the local database
        cursor.execute("""UPDATE wildfires SET t_updated = (?) WHERE fid == (?)""",
                       (datetime.now(), fire[0]))

    conn.commit()
    cursor.close()
    conn.close()

    if len(fires) > 0:
        print(str(len(fires)) + " wildfires were updated.")


# Delete wildfire with given SID from the database and HERE XYZ
def delete_fire(sid):
    conn = sqlite3.connect('db/db.sqlite')
    cursor = conn.cursor()

    # Delete wildfire from local SQLite database
    query = """DELETE FROM wildfires WHERE sid == (?)"""
    cursor.execute(query, (sid,))

    try:
        # Delete space from the HERE XYZ database
        requests.delete("https://xyz.api.here.com/hub/spaces/" + sid,
                        headers={'accept': 'application/json',
                                 'Authorization': "Bearer " + here_api_key})
    except requests.exceptions.ConnectionError:
        print("HERE XYZ cannot be reached.")

    # Obtain updated list of wildfires
    cursor.execute("SELECT sid, ROUND(latitude, 5), ROUND(longitude, 5), strftime('%d-%m-%Y %H:%M', t_init), strftime('%d-%m-%Y %H:%M', t_updated), comments, active FROM wildfires")
    rows = cursor.fetchall()

    conn.commit()
    cursor.close()
    conn.close()

    print("Wildfire " + sid + " was deleted from the system.")

    # Return updated list of wildfires
    return rows


# Insert a shape into HERE XYZ as a feature within a shape
def insert_feature(sid, shape):
    data = {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "geometry": shape
            }
        ]
    }

    try:
        requests.put("https://xyz.api.here.com/hub/spaces/" + sid + "/features",
                     data=json.dumps(data),
                     headers={'Authorization': "Bearer " + here_api_key,
                              "accept": "application/geo+json",
                              "Content-Type": "application/geo+json"})
    except requests.exceptions.ConnectionError:
        print("HERE XYZ cannot be reached.")


# Obtain wind speeds in X and Y-direction from the Windy API
def get_wind(lat, lon):
    try:
        # Request the wind speed at surface level using the GFS (global) model
        r = requests.post("https://api.windy.com/api/point-forecast/v2",
                          json={'lat': lat,
                                'lon': lon,
                                'model': 'gfs',
                                "parameters": ['wind'],
                                'key': windy_api_key},
                          timeout=2)
        data = r.json()
        wind_u = data['wind_u-surface'][2]
        wind_v = data['wind_v-surface'][2]

        return wind_u, wind_v

    except requests.exceptions.Timeout:
        # If the Windy API cannot be reached, set a default wind speed
        print("Windy API cannot be reached.")

        return 5.0, 5.0
